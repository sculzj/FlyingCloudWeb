{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(require(\"echarts\"));else if (typeof define === 'function' && define.amd) define([\"echarts\"], factory);else if (typeof exports === 'object') exports[\"echarts-liquidfill\"] = factory(require(\"echarts\"));else root[\"echarts-liquidfill\"] = factory(root[\"echarts\"]);\n})(self, function (__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {\n  return (\n    /******/\n    (() => {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        \"./index.js\":\n        /*!******************************!*\\\n          !*** ./index.js + 6 modules ***!\n          \\******************************/\n\n        /***/\n        (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n          // ESM COMPAT FLAG\n          __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: external \"echarts\"\n\n\n          var external_echarts_ = __webpack_require__(\"echarts/lib/echarts\");\n\n          ; // CONCATENATED MODULE: ./src/liquidFillSeries.js\n\n          external_echarts_.extendSeriesModel({\n            type: 'series.liquidFill',\n            optionUpdated: function () {\n              var option = this.option;\n              option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n            },\n            getInitialData: function (option, ecModel) {\n              var dimensions = external_echarts_.helper.createDimensions(option.data, {\n                coordDimensions: ['value']\n              });\n              var list = new external_echarts_.List(dimensions, this);\n              list.initData(option.data);\n              return list;\n            },\n            defaultOption: {\n              color: ['#294D99', '#156ACF', '#1598ED', '#45BDFF'],\n              center: ['50%', '50%'],\n              radius: '50%',\n              amplitude: '8%',\n              waveLength: '80%',\n              phase: 'auto',\n              period: 'auto',\n              direction: 'right',\n              shape: 'circle',\n              waveAnimation: true,\n              animationEasing: 'linear',\n              animationEasingUpdate: 'linear',\n              animationDuration: 2000,\n              animationDurationUpdate: 1000,\n              outline: {\n                show: true,\n                borderDistance: 8,\n                itemStyle: {\n                  color: 'none',\n                  borderColor: '#294D99',\n                  borderWidth: 8,\n                  shadowBlur: 20,\n                  shadowColor: 'rgba(0, 0, 0, 0.25)'\n                }\n              },\n              backgroundStyle: {\n                color: '#E3F7FF'\n              },\n              itemStyle: {\n                opacity: 0.95,\n                shadowBlur: 50,\n                shadowColor: 'rgba(0, 0, 0, 0.4)'\n              },\n              label: {\n                show: true,\n                color: '#294D99',\n                insideColor: '#fff',\n                fontSize: 50,\n                fontWeight: 'bold',\n                align: 'center',\n                baseline: 'middle',\n                position: 'inside'\n              },\n              emphasis: {\n                itemStyle: {\n                  opacity: 0.8\n                }\n              }\n            }\n          });\n          ; // CONCATENATED MODULE: ./node_modules/zrender/lib/core/util.js\n\n          var BUILTIN_OBJECT = {\n            '[object Function]': true,\n            '[object RegExp]': true,\n            '[object Date]': true,\n            '[object Error]': true,\n            '[object CanvasGradient]': true,\n            '[object CanvasPattern]': true,\n            '[object Image]': true,\n            '[object Canvas]': true\n          };\n          var TYPED_ARRAY = {\n            '[object Int8Array]': true,\n            '[object Uint8Array]': true,\n            '[object Uint8ClampedArray]': true,\n            '[object Int16Array]': true,\n            '[object Uint16Array]': true,\n            '[object Int32Array]': true,\n            '[object Uint32Array]': true,\n            '[object Float32Array]': true,\n            '[object Float64Array]': true\n          };\n          var objToString = Object.prototype.toString;\n          var arrayProto = Array.prototype;\n          var nativeForEach = arrayProto.forEach;\n          var nativeFilter = arrayProto.filter;\n          var nativeSlice = arrayProto.slice;\n          var nativeMap = arrayProto.map;\n\n          var ctorFunction = function () {}.constructor;\n\n          var protoFunction = ctorFunction ? ctorFunction.prototype : null;\n          var methods = {};\n\n          function $override(name, fn) {\n            methods[name] = fn;\n          }\n\n          var idStart = 0x0907;\n\n          function guid() {\n            return idStart++;\n          }\n\n          function logError() {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            if (typeof console !== 'undefined') {\n              console.error.apply(console, args);\n            }\n          }\n\n          function clone(source) {\n            if (source == null || typeof source !== 'object') {\n              return source;\n            }\n\n            var result = source;\n            var typeStr = objToString.call(source);\n\n            if (typeStr === '[object Array]') {\n              if (!isPrimitive(source)) {\n                result = [];\n\n                for (var i = 0, len = source.length; i < len; i++) {\n                  result[i] = clone(source[i]);\n                }\n              }\n            } else if (TYPED_ARRAY[typeStr]) {\n              if (!isPrimitive(source)) {\n                var Ctor = source.constructor;\n\n                if (Ctor.from) {\n                  result = Ctor.from(source);\n                } else {\n                  result = new Ctor(source.length);\n\n                  for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                  }\n                }\n              }\n            } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n              result = {};\n\n              for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                  result[key] = clone(source[key]);\n                }\n              }\n            }\n\n            return result;\n          }\n\n          function merge(target, source, overwrite) {\n            if (!isObject(source) || !isObject(target)) {\n              return overwrite ? clone(source) : target;\n            }\n\n            for (var key in source) {\n              if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n                  merge(targetProp, sourceProp, overwrite);\n                } else if (overwrite || !(key in target)) {\n                  target[key] = clone(source[key]);\n                }\n              }\n            }\n\n            return target;\n          }\n\n          function mergeAll(targetAndSources, overwrite) {\n            var result = targetAndSources[0];\n\n            for (var i = 1, len = targetAndSources.length; i < len; i++) {\n              result = merge(result, targetAndSources[i], overwrite);\n            }\n\n            return result;\n          }\n\n          function extend(target, source) {\n            if (Object.assign) {\n              Object.assign(target, source);\n            } else {\n              for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                  target[key] = source[key];\n                }\n              }\n            }\n\n            return target;\n          }\n\n          function defaults(target, source, overlay) {\n            var keysArr = keys(source);\n\n            for (var i = 0; i < keysArr.length; i++) {\n              var key = keysArr[i];\n\n              if (overlay ? source[key] != null : target[key] == null) {\n                target[key] = source[key];\n              }\n            }\n\n            return target;\n          }\n\n          var createCanvas = function () {\n            return methods.createCanvas();\n          };\n\n          methods.createCanvas = function () {\n            return document.createElement('canvas');\n          };\n\n          function indexOf(array, value) {\n            if (array) {\n              if (array.indexOf) {\n                return array.indexOf(value);\n              }\n\n              for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                  return i;\n                }\n              }\n            }\n\n            return -1;\n          }\n\n          function inherits(clazz, baseClazz) {\n            var clazzPrototype = clazz.prototype;\n\n            function F() {}\n\n            F.prototype = baseClazz.prototype;\n            clazz.prototype = new F();\n\n            for (var prop in clazzPrototype) {\n              if (clazzPrototype.hasOwnProperty(prop)) {\n                clazz.prototype[prop] = clazzPrototype[prop];\n              }\n            }\n\n            clazz.prototype.constructor = clazz;\n            clazz.superClass = baseClazz;\n          }\n\n          function mixin(target, source, override) {\n            target = 'prototype' in target ? target.prototype : target;\n            source = 'prototype' in source ? source.prototype : source;\n\n            if (Object.getOwnPropertyNames) {\n              var keyList = Object.getOwnPropertyNames(source);\n\n              for (var i = 0; i < keyList.length; i++) {\n                var key = keyList[i];\n\n                if (key !== 'constructor') {\n                  if (override ? source[key] != null : target[key] == null) {\n                    target[key] = source[key];\n                  }\n                }\n              }\n            } else {\n              defaults(target, source, override);\n            }\n          }\n\n          function isArrayLike(data) {\n            if (!data) {\n              return false;\n            }\n\n            if (typeof data === 'string') {\n              return false;\n            }\n\n            return typeof data.length === 'number';\n          }\n\n          function each(arr, cb, context) {\n            if (!(arr && cb)) {\n              return;\n            }\n\n            if (arr.forEach && arr.forEach === nativeForEach) {\n              arr.forEach(cb, context);\n            } else if (arr.length === +arr.length) {\n              for (var i = 0, len = arr.length; i < len; i++) {\n                cb.call(context, arr[i], i, arr);\n              }\n            } else {\n              for (var key in arr) {\n                if (arr.hasOwnProperty(key)) {\n                  cb.call(context, arr[key], key, arr);\n                }\n              }\n            }\n          }\n\n          function map(arr, cb, context) {\n            if (!arr) {\n              return [];\n            }\n\n            if (!cb) {\n              return slice(arr);\n            }\n\n            if (arr.map && arr.map === nativeMap) {\n              return arr.map(cb, context);\n            } else {\n              var result = [];\n\n              for (var i = 0, len = arr.length; i < len; i++) {\n                result.push(cb.call(context, arr[i], i, arr));\n              }\n\n              return result;\n            }\n          }\n\n          function reduce(arr, cb, memo, context) {\n            if (!(arr && cb)) {\n              return;\n            }\n\n            for (var i = 0, len = arr.length; i < len; i++) {\n              memo = cb.call(context, memo, arr[i], i, arr);\n            }\n\n            return memo;\n          }\n\n          function filter(arr, cb, context) {\n            if (!arr) {\n              return [];\n            }\n\n            if (!cb) {\n              return slice(arr);\n            }\n\n            if (arr.filter && arr.filter === nativeFilter) {\n              return arr.filter(cb, context);\n            } else {\n              var result = [];\n\n              for (var i = 0, len = arr.length; i < len; i++) {\n                if (cb.call(context, arr[i], i, arr)) {\n                  result.push(arr[i]);\n                }\n              }\n\n              return result;\n            }\n          }\n\n          function find(arr, cb, context) {\n            if (!(arr && cb)) {\n              return;\n            }\n\n            for (var i = 0, len = arr.length; i < len; i++) {\n              if (cb.call(context, arr[i], i, arr)) {\n                return arr[i];\n              }\n            }\n          }\n\n          function keys(obj) {\n            if (!obj) {\n              return [];\n            }\n\n            if (Object.keys) {\n              return Object.keys(obj);\n            }\n\n            var keyList = [];\n\n            for (var key in obj) {\n              if (obj.hasOwnProperty(key)) {\n                keyList.push(key);\n              }\n            }\n\n            return keyList;\n          }\n\n          function bindPolyfill(func, context) {\n            var args = [];\n\n            for (var _i = 2; _i < arguments.length; _i++) {\n              args[_i - 2] = arguments[_i];\n            }\n\n            return function () {\n              return func.apply(context, args.concat(nativeSlice.call(arguments)));\n            };\n          }\n\n          var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;\n\n          function curry(func) {\n            var args = [];\n\n            for (var _i = 1; _i < arguments.length; _i++) {\n              args[_i - 1] = arguments[_i];\n            }\n\n            return function () {\n              return func.apply(this, args.concat(nativeSlice.call(arguments)));\n            };\n          }\n\n          function isArray(value) {\n            if (Array.isArray) {\n              return Array.isArray(value);\n            }\n\n            return objToString.call(value) === '[object Array]';\n          }\n\n          function isFunction(value) {\n            return typeof value === 'function';\n          }\n\n          function isString(value) {\n            return typeof value === 'string';\n          }\n\n          function isStringSafe(value) {\n            return objToString.call(value) === '[object String]';\n          }\n\n          function isNumber(value) {\n            return typeof value === 'number';\n          }\n\n          function isObject(value) {\n            var type = typeof value;\n            return type === 'function' || !!value && type === 'object';\n          }\n\n          function isBuiltInObject(value) {\n            return !!BUILTIN_OBJECT[objToString.call(value)];\n          }\n\n          function isTypedArray(value) {\n            return !!TYPED_ARRAY[objToString.call(value)];\n          }\n\n          function isDom(value) {\n            return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n          }\n\n          function isGradientObject(value) {\n            return value.colorStops != null;\n          }\n\n          function isPatternObject(value) {\n            return value.image != null;\n          }\n\n          function isRegExp(value) {\n            return objToString.call(value) === '[object RegExp]';\n          }\n\n          function eqNaN(value) {\n            return value !== value;\n          }\n\n          function retrieve() {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            for (var i = 0, len = args.length; i < len; i++) {\n              if (args[i] != null) {\n                return args[i];\n              }\n            }\n          }\n\n          function retrieve2(value0, value1) {\n            return value0 != null ? value0 : value1;\n          }\n\n          function retrieve3(value0, value1, value2) {\n            return value0 != null ? value0 : value1 != null ? value1 : value2;\n          }\n\n          function slice(arr) {\n            var args = [];\n\n            for (var _i = 1; _i < arguments.length; _i++) {\n              args[_i - 1] = arguments[_i];\n            }\n\n            return nativeSlice.apply(arr, args);\n          }\n\n          function normalizeCssArray(val) {\n            if (typeof val === 'number') {\n              return [val, val, val, val];\n            }\n\n            var len = val.length;\n\n            if (len === 2) {\n              return [val[0], val[1], val[0], val[1]];\n            } else if (len === 3) {\n              return [val[0], val[1], val[2], val[1]];\n            }\n\n            return val;\n          }\n\n          function assert(condition, message) {\n            if (!condition) {\n              throw new Error(message);\n            }\n          }\n\n          function trim(str) {\n            if (str == null) {\n              return null;\n            } else if (typeof str.trim === 'function') {\n              return str.trim();\n            } else {\n              return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n            }\n          }\n\n          var primitiveKey = '__ec_primitive__';\n\n          function setAsPrimitive(obj) {\n            obj[primitiveKey] = true;\n          }\n\n          function isPrimitive(obj) {\n            return obj[primitiveKey];\n          }\n\n          var HashMap = function () {\n            function HashMap(obj) {\n              this.data = {};\n              var isArr = isArray(obj);\n              this.data = {};\n              var thisMap = this;\n              obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);\n\n              function visit(value, key) {\n                isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n              }\n            }\n\n            HashMap.prototype.get = function (key) {\n              return this.data.hasOwnProperty(key) ? this.data[key] : null;\n            };\n\n            HashMap.prototype.set = function (key, value) {\n              return this.data[key] = value;\n            };\n\n            HashMap.prototype.each = function (cb, context) {\n              for (var key in this.data) {\n                if (this.data.hasOwnProperty(key)) {\n                  cb.call(context, this.data[key], key);\n                }\n              }\n            };\n\n            HashMap.prototype.keys = function () {\n              return keys(this.data);\n            };\n\n            HashMap.prototype.removeKey = function (key) {\n              delete this.data[key];\n            };\n\n            return HashMap;\n          }();\n\n          function createHashMap(obj) {\n            return new HashMap(obj);\n          }\n\n          function concatArray(a, b) {\n            var newArray = new a.constructor(a.length + b.length);\n\n            for (var i = 0; i < a.length; i++) {\n              newArray[i] = a[i];\n            }\n\n            var offset = a.length;\n\n            for (var i = 0; i < b.length; i++) {\n              newArray[i + offset] = b[i];\n            }\n\n            return newArray;\n          }\n\n          function createObject(proto, properties) {\n            var obj;\n\n            if (Object.create) {\n              obj = Object.create(proto);\n            } else {\n              var StyleCtor = function () {};\n\n              StyleCtor.prototype = proto;\n              obj = new StyleCtor();\n            }\n\n            if (properties) {\n              extend(obj, properties);\n            }\n\n            return obj;\n          }\n\n          function hasOwn(own, prop) {\n            return own.hasOwnProperty(prop);\n          }\n\n          function noop() {}\n\n          ; // CONCATENATED MODULE: ./node_modules/echarts/lib/util/number.js\n\n          /*\n          * Licensed to the Apache Software Foundation (ASF) under one\n          * or more contributor license agreements.  See the NOTICE file\n          * distributed with this work for additional information\n          * regarding copyright ownership.  The ASF licenses this file\n          * to you under the Apache License, Version 2.0 (the\n          * \"License\"); you may not use this file except in compliance\n          * with the License.  You may obtain a copy of the License at\n          *\n          *   http://www.apache.org/licenses/LICENSE-2.0\n          *\n          * Unless required by applicable law or agreed to in writing,\n          * software distributed under the License is distributed on an\n          * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n          * KIND, either express or implied.  See the License for the\n          * specific language governing permissions and limitations\n          * under the License.\n          */\n\n          /**\n           * AUTO-GENERATED FILE. DO NOT MODIFY.\n           */\n\n          var RADIAN_EPSILON = 1e-4;\n\n          function _trim(str) {\n            return str.replace(/^\\s+|\\s+$/g, '');\n          }\n\n          function linearMap(val, domain, range, clamp) {\n            var subDomain = domain[1] - domain[0];\n            var subRange = range[1] - range[0];\n\n            if (subDomain === 0) {\n              return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n            }\n\n            if (clamp) {\n              if (subDomain > 0) {\n                if (val <= domain[0]) {\n                  return range[0];\n                } else if (val >= domain[1]) {\n                  return range[1];\n                }\n              } else {\n                if (val >= domain[0]) {\n                  return range[0];\n                } else if (val <= domain[1]) {\n                  return range[1];\n                }\n              }\n            } else {\n              if (val === domain[0]) {\n                return range[0];\n              }\n\n              if (val === domain[1]) {\n                return range[1];\n              }\n            }\n\n            return (val - domain[0]) / subDomain * subRange + range[0];\n          }\n\n          function parsePercent(percent, all) {\n            switch (percent) {\n              case 'center':\n              case 'middle':\n                percent = '50%';\n                break;\n\n              case 'left':\n              case 'top':\n                percent = '0%';\n                break;\n\n              case 'right':\n              case 'bottom':\n                percent = '100%';\n                break;\n            }\n\n            if (typeof percent === 'string') {\n              if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n              }\n\n              return parseFloat(percent);\n            }\n\n            return percent == null ? NaN : +percent;\n          }\n\n          function round(x, precision, returnStr) {\n            if (precision == null) {\n              precision = 10;\n            }\n\n            precision = Math.min(Math.max(0, precision), 20);\n            x = (+x).toFixed(precision);\n            return returnStr ? x : +x;\n          }\n\n          function asc(arr) {\n            arr.sort(function (a, b) {\n              return a - b;\n            });\n            return arr;\n          }\n\n          function getPrecision(val) {\n            val = +val;\n\n            if (isNaN(val)) {\n              return 0;\n            }\n\n            var e = 1;\n            var count = 0;\n\n            while (Math.round(val * e) / e !== val) {\n              e *= 10;\n              count++;\n            }\n\n            return count;\n          }\n\n          function getPrecisionSafe(val) {\n            var str = val.toString();\n            var eIndex = str.indexOf('e');\n\n            if (eIndex > 0) {\n              var precision = +str.slice(eIndex + 1);\n              return precision < 0 ? -precision : 0;\n            } else {\n              var dotIndex = str.indexOf('.');\n              return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n            }\n          }\n\n          function getPixelPrecision(dataExtent, pixelExtent) {\n            var log = Math.log;\n            var LN10 = Math.LN10;\n            var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n            var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n            var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n            return !isFinite(precision) ? 20 : precision;\n          }\n\n          function getPercentWithPrecision(valueList, idx, precision) {\n            if (!valueList[idx]) {\n              return 0;\n            }\n\n            var sum = reduce(valueList, function (acc, val) {\n              return acc + (isNaN(val) ? 0 : val);\n            }, 0);\n\n            if (sum === 0) {\n              return 0;\n            }\n\n            var digits = Math.pow(10, precision);\n            var votesPerQuota = map(valueList, function (val) {\n              return (isNaN(val) ? 0 : val) / sum * digits * 100;\n            });\n            var targetSeats = digits * 100;\n            var seats = map(votesPerQuota, function (votes) {\n              return Math.floor(votes);\n            });\n            var currentSum = reduce(seats, function (acc, val) {\n              return acc + val;\n            }, 0);\n            var remainder = map(votesPerQuota, function (votes, idx) {\n              return votes - seats[idx];\n            });\n\n            while (currentSum < targetSeats) {\n              var max = Number.NEGATIVE_INFINITY;\n              var maxId = null;\n\n              for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                  max = remainder[i];\n                  maxId = i;\n                }\n              }\n\n              ++seats[maxId];\n              remainder[maxId] = 0;\n              ++currentSum;\n            }\n\n            return seats[idx] / digits;\n          }\n\n          var MAX_SAFE_INTEGER = 9007199254740991;\n\n          function remRadian(radian) {\n            var pi2 = Math.PI * 2;\n            return (radian % pi2 + pi2) % pi2;\n          }\n\n          function isRadianAroundZero(val) {\n            return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n          }\n\n          var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/;\n\n          function parseDate(value) {\n            if (value instanceof Date) {\n              return value;\n            } else if (typeof value === 'string') {\n              var match = TIME_REG.exec(value);\n\n              if (!match) {\n                return new Date(NaN);\n              }\n\n              if (!match[8]) {\n                return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n              } else {\n                var hour = +match[4] || 0;\n\n                if (match[8].toUpperCase() !== 'Z') {\n                  hour -= +match[8].slice(0, 3);\n                }\n\n                return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n              }\n            } else if (value == null) {\n              return new Date(NaN);\n            }\n\n            return new Date(Math.round(value));\n          }\n\n          function quantity(val) {\n            return Math.pow(10, quantityExponent(val));\n          }\n\n          function quantityExponent(val) {\n            if (val === 0) {\n              return 0;\n            }\n\n            var exp = Math.floor(Math.log(val) / Math.LN10);\n\n            if (val / Math.pow(10, exp) >= 10) {\n              exp++;\n            }\n\n            return exp;\n          }\n\n          function nice(val, round) {\n            var exponent = quantityExponent(val);\n            var exp10 = Math.pow(10, exponent);\n            var f = val / exp10;\n            var nf;\n\n            if (round) {\n              if (f < 1.5) {\n                nf = 1;\n              } else if (f < 2.5) {\n                nf = 2;\n              } else if (f < 4) {\n                nf = 3;\n              } else if (f < 7) {\n                nf = 5;\n              } else {\n                nf = 10;\n              }\n            } else {\n              if (f < 1) {\n                nf = 1;\n              } else if (f < 2) {\n                nf = 2;\n              } else if (f < 3) {\n                nf = 3;\n              } else if (f < 5) {\n                nf = 5;\n              } else {\n                nf = 10;\n              }\n            }\n\n            val = nf * exp10;\n            return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n          }\n\n          function quantile(ascArr, p) {\n            var H = (ascArr.length - 1) * p + 1;\n            var h = Math.floor(H);\n            var v = +ascArr[h - 1];\n            var e = H - h;\n            return e ? v + e * (ascArr[h] - v) : v;\n          }\n\n          function reformIntervals(list) {\n            list.sort(function (a, b) {\n              return littleThan(a, b, 0) ? -1 : 1;\n            });\n            var curr = -Infinity;\n            var currClose = 1;\n\n            for (var i = 0; i < list.length;) {\n              var interval = list[i].interval;\n              var close_1 = list[i].close;\n\n              for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                  interval[lg] = curr;\n                  close_1[lg] = !lg ? 1 - currClose : 1;\n                }\n\n                curr = interval[lg];\n                currClose = close_1[lg];\n              }\n\n              if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {\n                list.splice(i, 1);\n              } else {\n                i++;\n              }\n            }\n\n            return list;\n\n            function littleThan(a, b, lg) {\n              return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n            }\n          }\n\n          function numericToNumber(val) {\n            var valFloat = parseFloat(val);\n            return valFloat == val && (valFloat !== 0 || typeof val !== 'string' || val.indexOf('x') <= 0) ? valFloat : NaN;\n          }\n\n          function isNumeric(val) {\n            return !isNaN(numericToNumber(val));\n          }\n\n          function getRandomIdBase() {\n            return Math.round(Math.random() * 9);\n          }\n\n          function getGreatestCommonDividor(a, b) {\n            if (b === 0) {\n              return a;\n            }\n\n            return getGreatestCommonDividor(b, a % b);\n          }\n\n          function getLeastCommonMultiple(a, b) {\n            if (a == null) {\n              return b;\n            }\n\n            if (b == null) {\n              return a;\n            }\n\n            return a * b / getGreatestCommonDividor(a, b);\n          }\n\n          ; // CONCATENATED MODULE: ./src/liquidFillShape.js\n\n          /* harmony default export */\n\n          const liquidFillShape = external_echarts_.graphic.extendShape({\n            type: 'ec-liquid-fill',\n            shape: {\n              waveLength: 0,\n              radius: 0,\n              radiusY: 0,\n              cx: 0,\n              cy: 0,\n              waterLevel: 0,\n              amplitude: 0,\n              phase: 0,\n              inverse: false\n            },\n            buildPath: function (ctx, shape) {\n              if (shape.radiusY == null) {\n                shape.radiusY = shape.radius;\n              }\n              /**\n               * We define a sine wave having 4 waves, and make sure at least 8 curves\n               * is drawn. Otherwise, it may cause blank area for some waves when\n               * wave length is large enough.\n               */\n\n\n              var curves = Math.max(Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2, 8); // map phase to [-Math.PI * 2, 0]\n\n              while (shape.phase < -Math.PI * 2) {\n                shape.phase += Math.PI * 2;\n              }\n\n              while (shape.phase > 0) {\n                shape.phase -= Math.PI * 2;\n              }\n\n              var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n              var left = shape.cx - shape.radius + phase - shape.radius * 2;\n              /**\n               * top-left corner as start point\n               *\n               * draws this point\n               *  |\n               * \\|/\n               *  ~~~~~~~~\n               *  |      |\n               *  +------+\n               */\n\n              ctx.moveTo(left, shape.waterLevel);\n              /**\n               * top wave\n               *\n               * ~~~~~~~~ <- draws this sine wave\n               * |      |\n               * +------+\n               */\n\n              var waveRight = 0;\n\n              for (var c = 0; c < curves; ++c) {\n                var stage = c % 4;\n                var pos = getWaterPositions(c * shape.waveLength / 4, stage, shape.waveLength, shape.amplitude);\n                ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel, pos[1][0] + left, -pos[1][1] + shape.waterLevel, pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n                if (c === curves - 1) {\n                  waveRight = pos[2][0];\n                }\n              }\n\n              if (shape.inverse) {\n                /**\n                 * top-right corner\n                 *                  2. draws this line\n                 *                          |\n                 *                       +------+\n                 * 3. draws this line -> |      | <- 1. draws this line\n                 *                       ~~~~~~~~\n                 */\n                ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n                ctx.lineTo(left, shape.cy - shape.radiusY);\n                ctx.lineTo(left, shape.waterLevel);\n              } else {\n                /**\n                 * top-right corner\n                 *\n                 *                       ~~~~~~~~\n                 * 3. draws this line -> |      | <- 1. draws this line\n                 *                       +------+\n                 *                          ^\n                 *                          |\n                 *                  2. draws this line\n                 */\n                ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n                ctx.lineTo(left, shape.cy + shape.radiusY);\n                ctx.lineTo(left, shape.waterLevel);\n              }\n\n              ctx.closePath();\n            }\n          });\n          /**\n           * Using Bezier curves to fit sine wave.\n           * There is 4 control points for each curve of wave,\n           * which is at 1/4 wave length of the sine wave.\n           *\n           * The control points for a wave from (a) to (d) are a-b-c-d:\n           *          c *----* d\n           *     b *\n           *       |\n           * ... a * ..................\n           *\n           * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n           *\n           * @param {number} x          x position of the left-most point (a)\n           * @param {number} stage      0-3, stating which part of the wave it is\n           * @param {number} waveLength wave length of the sine wave\n           * @param {number} amplitude  wave amplitude\n           */\n\n          function getWaterPositions(x, stage, waveLength, amplitude) {\n            if (stage === 0) {\n              return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n            } else if (stage === 1) {\n              return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n            } else if (stage === 2) {\n              return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n            } else {\n              return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n            }\n          }\n\n          ; // CONCATENATED MODULE: ./src/liquidFillView.js\n\n          const liquidFillView_parsePercent = parsePercent;\n          external_echarts_.extendChartView({\n            type: 'liquidFill',\n            render: function (seriesModel, ecModel, api) {\n              var group = this.group;\n              group.removeAll();\n              var data = seriesModel.getData();\n              var itemModel = data.getItemModel(0);\n              var center = itemModel.get('center');\n              var radius = itemModel.get('radius');\n              var width = api.getWidth();\n              var height = api.getHeight();\n              var size = Math.min(width, height); // itemStyle\n\n              var outlineDistance = 0;\n              var outlineBorderWidth = 0;\n              var showOutline = seriesModel.get('outline.show');\n\n              if (showOutline) {\n                outlineDistance = seriesModel.get('outline.borderDistance');\n                outlineBorderWidth = liquidFillView_parsePercent(seriesModel.get('outline.itemStyle.borderWidth'), size);\n              }\n\n              var cx = liquidFillView_parsePercent(center[0], width);\n              var cy = liquidFillView_parsePercent(center[1], height);\n              var outterRadius;\n              var innerRadius;\n              var paddingRadius;\n              var isFillContainer = false;\n              var symbol = seriesModel.get('shape');\n\n              if (symbol === 'container') {\n                // a shape that fully fills the container\n                isFillContainer = true;\n                outterRadius = [width / 2, height / 2];\n                innerRadius = [outterRadius[0] - outlineBorderWidth / 2, outterRadius[1] - outlineBorderWidth / 2];\n                paddingRadius = [liquidFillView_parsePercent(outlineDistance, width), liquidFillView_parsePercent(outlineDistance, height)];\n                radius = [Math.max(innerRadius[0] - paddingRadius[0], 0), Math.max(innerRadius[1] - paddingRadius[1], 0)];\n              } else {\n                outterRadius = liquidFillView_parsePercent(radius, size) / 2;\n                innerRadius = outterRadius - outlineBorderWidth / 2;\n                paddingRadius = liquidFillView_parsePercent(outlineDistance, size);\n                radius = Math.max(innerRadius - paddingRadius, 0);\n              }\n\n              if (showOutline) {\n                var outline = getOutline();\n                outline.style.lineWidth = outlineBorderWidth;\n                group.add(getOutline());\n              }\n\n              var left = isFillContainer ? 0 : cx - radius;\n              var top = isFillContainer ? 0 : cy - radius;\n              var wavePath = null;\n              group.add(getBackground()); // each data item for a wave\n\n              var oldData = this._data;\n              var waves = [];\n              data.diff(oldData).add(function (idx) {\n                var wave = getWave(idx, false);\n                var waterLevel = wave.shape.waterLevel;\n                wave.shape.waterLevel = isFillContainer ? height / 2 : radius;\n                external_echarts_.graphic.initProps(wave, {\n                  shape: {\n                    waterLevel: waterLevel\n                  }\n                }, seriesModel);\n                wave.z2 = 2;\n                setWaveAnimation(idx, wave, null);\n                group.add(wave);\n                data.setItemGraphicEl(idx, wave);\n                waves.push(wave);\n              }).update(function (newIdx, oldIdx) {\n                var waveElement = oldData.getItemGraphicEl(oldIdx); // new wave is used to calculate position, but not added\n\n                var newWave = getWave(newIdx, false, waveElement); // changes with animation\n\n                var shape = {};\n                var shapeAttrs = ['amplitude', 'cx', 'cy', 'phase', 'radius', 'radiusY', 'waterLevel', 'waveLength'];\n\n                for (var i = 0; i < shapeAttrs.length; ++i) {\n                  var attr = shapeAttrs[i];\n\n                  if (newWave.shape.hasOwnProperty(attr)) {\n                    shape[attr] = newWave.shape[attr];\n                  }\n                }\n\n                var style = {};\n                var styleAttrs = ['fill', 'opacity', 'shadowBlur', 'shadowColor'];\n\n                for (var i = 0; i < styleAttrs.length; ++i) {\n                  var attr = styleAttrs[i];\n\n                  if (newWave.style.hasOwnProperty(attr)) {\n                    style[attr] = newWave.style[attr];\n                  }\n                }\n\n                if (isFillContainer) {\n                  shape.radiusY = height / 2;\n                } // changes with animation\n\n\n                external_echarts_.graphic.updateProps(waveElement, {\n                  shape: shape\n                }, seriesModel);\n                waveElement.useStyle(style); // instant changes\n\n                waveElement.position = newWave.position;\n                waveElement.setClipPath(newWave.getClipPath());\n                waveElement.shape.inverse = newWave.inverse;\n                setWaveAnimation(newIdx, waveElement, waveElement);\n                group.add(waveElement);\n                data.setItemGraphicEl(newIdx, waveElement);\n                waves.push(waveElement);\n              }).remove(function (idx) {\n                var wave = oldData.getItemGraphicEl(idx);\n                group.remove(wave);\n              }).execute();\n\n              if (itemModel.get('label.show')) {\n                group.add(getText(waves));\n              }\n\n              this._data = data;\n              /**\n               * Get path for outline, background and clipping\n               *\n               * @param {number} r outter radius of shape\n               * @param {boolean|undefined} isForClipping if the shape is used\n               *                                          for clipping\n               */\n\n              function getPath(r, isForClipping) {\n                if (symbol) {\n                  // customed symbol path\n                  if (symbol.indexOf('path://') === 0) {\n                    var path = external_echarts_.graphic.makePath(symbol.slice(7), {});\n                    var bouding = path.getBoundingRect();\n                    var w = bouding.width;\n                    var h = bouding.height;\n\n                    if (w > h) {\n                      h = r * 2 / w * h;\n                      w = r * 2;\n                    } else {\n                      w = r * 2 / h * w;\n                      h = r * 2;\n                    }\n\n                    var left = isForClipping ? 0 : cx - w / 2;\n                    var top = isForClipping ? 0 : cy - h / 2;\n                    path = external_echarts_.graphic.makePath(symbol.slice(7), {}, new external_echarts_.graphic.BoundingRect(left, top, w, h));\n\n                    if (isForClipping) {\n                      path.position = [-w / 2, -h / 2];\n                    }\n\n                    return path;\n                  } else if (isFillContainer) {\n                    // fully fill the container\n                    var x = isForClipping ? -r[0] : cx - r[0];\n                    var y = isForClipping ? -r[1] : cy - r[1];\n                    return external_echarts_.helper.createSymbol('rect', x, y, r[0] * 2, r[1] * 2);\n                  } else {\n                    var x = isForClipping ? -r : cx - r;\n                    var y = isForClipping ? -r : cy - r;\n\n                    if (symbol === 'pin') {\n                      y += r;\n                    } else if (symbol === 'arrow') {\n                      y -= r;\n                    }\n\n                    return external_echarts_.helper.createSymbol(symbol, x, y, r * 2, r * 2);\n                  }\n                }\n\n                return new external_echarts_.graphic.Circle({\n                  shape: {\n                    cx: isForClipping ? 0 : cx,\n                    cy: isForClipping ? 0 : cy,\n                    r: r\n                  }\n                });\n              }\n              /**\n               * Create outline\n               */\n\n\n              function getOutline() {\n                var outlinePath = getPath(outterRadius);\n                outlinePath.style.fill = null;\n                outlinePath.setStyle(seriesModel.getModel('outline.itemStyle').getItemStyle());\n                return outlinePath;\n              }\n              /**\n               * Create background\n               */\n\n\n              function getBackground() {\n                // Seperate stroke and fill, so we can use stroke to cover the alias of clipping.\n                var strokePath = getPath(radius);\n                strokePath.setStyle(seriesModel.getModel('backgroundStyle').getItemStyle());\n                strokePath.style.fill = null; // Stroke is front of wave\n\n                strokePath.z2 = 5;\n                var fillPath = getPath(radius);\n                fillPath.setStyle(seriesModel.getModel('backgroundStyle').getItemStyle());\n                fillPath.style.stroke = null;\n                var group = new external_echarts_.graphic.Group();\n                group.add(strokePath);\n                group.add(fillPath);\n                return group;\n              }\n              /**\n               * wave shape\n               */\n\n\n              function getWave(idx, isInverse, oldWave) {\n                var radiusX = isFillContainer ? radius[0] : radius;\n                var radiusY = isFillContainer ? height / 2 : radius;\n                var itemModel = data.getItemModel(idx);\n                var itemStyleModel = itemModel.getModel('itemStyle');\n                var phase = itemModel.get('phase');\n                var amplitude = liquidFillView_parsePercent(itemModel.get('amplitude'), radiusY * 2);\n                var waveLength = liquidFillView_parsePercent(itemModel.get('waveLength'), radiusX * 2);\n                var value = data.get('value', idx);\n                var waterLevel = radiusY - value * radiusY * 2;\n                phase = oldWave ? oldWave.shape.phase : phase === 'auto' ? idx * Math.PI / 4 : phase;\n                var normalStyle = itemStyleModel.getItemStyle();\n\n                if (!normalStyle.fill) {\n                  var seriesColor = seriesModel.get('color');\n                  var id = idx % seriesColor.length;\n                  normalStyle.fill = seriesColor[id];\n                }\n\n                var x = radiusX * 2;\n                var wave = new liquidFillShape({\n                  shape: {\n                    waveLength: waveLength,\n                    radius: radiusX,\n                    radiusY: radiusY,\n                    cx: x,\n                    cy: 0,\n                    waterLevel: waterLevel,\n                    amplitude: amplitude,\n                    phase: phase,\n                    inverse: isInverse\n                  },\n                  style: normalStyle,\n                  position: [cx, cy]\n                });\n                wave.shape._waterLevel = waterLevel;\n                var hoverStyle = itemModel.getModel('emphasis.itemStyle').getItemStyle();\n                hoverStyle.lineWidth = 0;\n                wave.ensureState('emphasis').style = hoverStyle;\n                external_echarts_.helper.enableHoverEmphasis(wave); // clip out the part outside the circle\n\n                var clip = getPath(radius, true); // set fill for clipPath, otherwise it will not trigger hover event\n\n                clip.setStyle({\n                  fill: 'white'\n                });\n                wave.setClipPath(clip);\n                return wave;\n              }\n\n              function setWaveAnimation(idx, wave, oldWave) {\n                var itemModel = data.getItemModel(idx);\n                var maxSpeed = itemModel.get('period');\n                var direction = itemModel.get('direction');\n                var value = data.get('value', idx);\n                var phase = itemModel.get('phase');\n                phase = oldWave ? oldWave.shape.phase : phase === 'auto' ? idx * Math.PI / 4 : phase;\n\n                var defaultSpeed = function (maxSpeed) {\n                  var cnt = data.count();\n                  return cnt === 0 ? maxSpeed : maxSpeed * (0.2 + (cnt - idx) / cnt * 0.8);\n                };\n\n                var speed = 0;\n\n                if (maxSpeed === 'auto') {\n                  speed = defaultSpeed(5000);\n                } else {\n                  speed = typeof maxSpeed === 'function' ? maxSpeed(value, idx) : maxSpeed;\n                } // phase for moving left/right\n\n\n                var phaseOffset = 0;\n\n                if (direction === 'right' || direction == null) {\n                  phaseOffset = Math.PI;\n                } else if (direction === 'left') {\n                  phaseOffset = -Math.PI;\n                } else if (direction === 'none') {\n                  phaseOffset = 0;\n                } else {\n                  console.error('Illegal direction value for liquid fill.');\n                } // wave animation of moving left/right\n\n\n                if (direction !== 'none' && itemModel.get('waveAnimation')) {\n                  wave.animate('shape', true).when(0, {\n                    phase: phase\n                  }).when(speed / 2, {\n                    phase: phaseOffset + phase\n                  }).when(speed, {\n                    phase: phaseOffset * 2 + phase\n                  }).during(function () {\n                    if (wavePath) {\n                      wavePath.dirty(true);\n                    }\n                  }).start();\n                }\n              }\n              /**\n               * text on wave\n               */\n\n\n              function getText(waves) {\n                var labelModel = itemModel.getModel('label');\n\n                function formatLabel() {\n                  var formatted = seriesModel.getFormattedLabel(0, 'normal');\n                  var defaultVal = data.get('value', 0) * 100;\n                  var defaultLabel = data.getName(0) || seriesModel.name;\n\n                  if (!isNaN(defaultVal)) {\n                    defaultLabel = defaultVal.toFixed(0) + '%';\n                  }\n\n                  return formatted == null ? defaultLabel : formatted;\n                }\n\n                var textRectOption = {\n                  z2: 10,\n                  shape: {\n                    x: left,\n                    y: top,\n                    width: (isFillContainer ? radius[0] : radius) * 2,\n                    height: (isFillContainer ? radius[1] : radius) * 2\n                  },\n                  style: {\n                    fill: 'transparent'\n                  },\n                  textConfig: {\n                    position: labelModel.get('position') || 'inside'\n                  },\n                  silent: true\n                };\n                var textOption = {\n                  style: {\n                    text: formatLabel(),\n                    textAlign: labelModel.get('align'),\n                    textVerticalAlign: labelModel.get('baseline')\n                  }\n                };\n                Object.assign(textOption.style, external_echarts_.helper.createTextStyle(labelModel));\n                var outsideTextRect = new external_echarts_.graphic.Rect(textRectOption);\n                var insideTextRect = new external_echarts_.graphic.Rect(textRectOption);\n                insideTextRect.disableLabelAnimation = true;\n                outsideTextRect.disableLabelAnimation = true;\n                var outsideText = new external_echarts_.graphic.Text(textOption);\n                var insideText = new external_echarts_.graphic.Text(textOption);\n                outsideTextRect.setTextContent(outsideText);\n                insideTextRect.setTextContent(insideText);\n                var insColor = labelModel.get('insideColor');\n                insideText.style.fill = insColor;\n                var group = new external_echarts_.graphic.Group();\n                group.add(outsideTextRect);\n                group.add(insideTextRect); // clip out waves for insideText\n\n                var boundingCircle = getPath(radius, true);\n                wavePath = new external_echarts_.graphic.CompoundPath({\n                  shape: {\n                    paths: waves\n                  },\n                  position: [cx, cy]\n                });\n                wavePath.setClipPath(boundingCircle);\n                insideTextRect.setClipPath(wavePath);\n                return group;\n              }\n            },\n            dispose: function () {// dispose nothing here\n            }\n          });\n          ; // CONCATENATED MODULE: ./src/liquidFill.js\n\n          ; // CONCATENATED MODULE: ./index.js\n\n          /***/\n        },\n\n        /***/\n        \"echarts/lib/echarts\":\n        /*!**************************!*\\\n          !*** external \"echarts\" ***!\n          \\**************************/\n\n        /***/\n        module => {\n          module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;\n          /***/\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/make namespace object */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define __esModule on exports\n\n        /******/\n        __webpack_require__.r = exports => {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n\n      return __webpack_require__(\"./index.js\");\n      /******/\n    })()\n  );\n});","map":{"version":3,"sources":["webpack://echarts-liquidfill/webpack/universalModuleDefinition","webpack://echarts-liquidfill/src/liquidFillSeries.js","webpack://echarts-liquidfill/node_modules/zrender/lib/core/util.js","webpack://echarts-liquidfill/node_modules/echarts/lib/util/number.js","webpack://echarts-liquidfill/src/liquidFillShape.js","webpack://echarts-liquidfill/src/liquidFillView.js","webpack:/echarts-liquidfill/external \"echarts\"","webpack://echarts-liquidfill/webpack/bootstrap","webpack:/echarts-liquidfill/webpack/runtime/make namespace object","webpack://echarts-liquidfill/webpack/startup"],"names":[],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"echarts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"echarts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts-liquidfill\"] = factory(require(\"echarts\"));\n\telse\n\t\troot[\"echarts-liquidfill\"] = factory(root[\"echarts\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {\nreturn ","import * as echarts from 'echarts/lib/echarts';\n\necharts.extendSeriesModel({\n\n    type: 'series.liquidFill',\n\n    optionUpdated: function () {\n        var option = this.option;\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = echarts.helper.createDimensions(option.data, {\n            coordDimensions: ['value']\n        });\n        var list = new echarts.List(dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    defaultOption: {\n        color: ['#294D99', '#156ACF', '#1598ED', '#45BDFF'],\n        center: ['50%', '50%'],\n        radius: '50%',\n        amplitude: '8%',\n        waveLength: '80%',\n        phase: 'auto',\n        period: 'auto',\n        direction: 'right',\n        shape: 'circle',\n\n        waveAnimation: true,\n        animationEasing: 'linear',\n        animationEasingUpdate: 'linear',\n        animationDuration: 2000,\n        animationDurationUpdate: 1000,\n\n        outline: {\n            show: true,\n            borderDistance: 8,\n            itemStyle: {\n                color: 'none',\n                borderColor: '#294D99',\n                borderWidth: 8,\n                shadowBlur: 20,\n                shadowColor: 'rgba(0, 0, 0, 0.25)'\n            }\n        },\n\n        backgroundStyle: {\n            color: '#E3F7FF'\n        },\n\n        itemStyle: {\n            opacity: 0.95,\n            shadowBlur: 50,\n            shadowColor: 'rgba(0, 0, 0, 0.4)'\n        },\n\n        label: {\n            show: true,\n            color: '#294D99',\n            insideColor: '#fff',\n            fontSize: 50,\n            fontWeight: 'bold',\n\n            align: 'center',\n            baseline: 'middle',\n            position: 'inside'\n        },\n\n        emphasis: {\n            itemStyle: {\n                opacity: 0.8\n            }\n        }\n    }\n});\n","var BUILTIN_OBJECT = {\n    '[object Function]': true,\n    '[object RegExp]': true,\n    '[object Date]': true,\n    '[object Error]': true,\n    '[object CanvasGradient]': true,\n    '[object CanvasPattern]': true,\n    '[object Image]': true,\n    '[object Canvas]': true\n};\nvar TYPED_ARRAY = {\n    '[object Int8Array]': true,\n    '[object Uint8Array]': true,\n    '[object Uint8ClampedArray]': true,\n    '[object Int16Array]': true,\n    '[object Uint16Array]': true,\n    '[object Int32Array]': true,\n    '[object Uint32Array]': true,\n    '[object Float32Array]': true,\n    '[object Float64Array]': true\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar ctorFunction = function () { }.constructor;\nvar protoFunction = ctorFunction ? ctorFunction.prototype : null;\nvar methods = {};\nexport function $override(name, fn) {\n    methods[name] = fn;\n}\nvar idStart = 0x0907;\nexport function guid() {\n    return idStart++;\n}\nexport function logError() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (typeof console !== 'undefined') {\n        console.error.apply(console, args);\n    }\n}\nexport function clone(source) {\n    if (source == null || typeof source !== 'object') {\n        return source;\n    }\n    var result = source;\n    var typeStr = objToString.call(source);\n    if (typeStr === '[object Array]') {\n        if (!isPrimitive(source)) {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n    }\n    else if (TYPED_ARRAY[typeStr]) {\n        if (!isPrimitive(source)) {\n            var Ctor = source.constructor;\n            if (Ctor.from) {\n                result = Ctor.from(source);\n            }\n            else {\n                result = new Ctor(source.length);\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n        }\n    }\n    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n        result = {};\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                result[key] = clone(source[key]);\n            }\n        }\n    }\n    return result;\n}\nexport function merge(target, source, overwrite) {\n    if (!isObject(source) || !isObject(target)) {\n        return overwrite ? clone(source) : target;\n    }\n    for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n            var targetProp = target[key];\n            var sourceProp = source[key];\n            if (isObject(sourceProp)\n                && isObject(targetProp)\n                && !isArray(sourceProp)\n                && !isArray(targetProp)\n                && !isDom(sourceProp)\n                && !isDom(targetProp)\n                && !isBuiltInObject(sourceProp)\n                && !isBuiltInObject(targetProp)\n                && !isPrimitive(sourceProp)\n                && !isPrimitive(targetProp)) {\n                merge(targetProp, sourceProp, overwrite);\n            }\n            else if (overwrite || !(key in target)) {\n                target[key] = clone(source[key]);\n            }\n        }\n    }\n    return target;\n}\nexport function mergeAll(targetAndSources, overwrite) {\n    var result = targetAndSources[0];\n    for (var i = 1, len = targetAndSources.length; i < len; i++) {\n        result = merge(result, targetAndSources[i], overwrite);\n    }\n    return result;\n}\nexport function extend(target, source) {\n    if (Object.assign) {\n        Object.assign(target, source);\n    }\n    else {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\nexport function defaults(target, source, overlay) {\n    var keysArr = keys(source);\n    for (var i = 0; i < keysArr.length; i++) {\n        var key = keysArr[i];\n        if ((overlay ? source[key] != null : target[key] == null)) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nexport var createCanvas = function () {\n    return methods.createCanvas();\n};\nmethods.createCanvas = function () {\n    return document.createElement('canvas');\n};\nexport function indexOf(array, value) {\n    if (array) {\n        if (array.indexOf) {\n            return array.indexOf(value);\n        }\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === value) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nexport function inherits(clazz, baseClazz) {\n    var clazzPrototype = clazz.prototype;\n    function F() { }\n    F.prototype = baseClazz.prototype;\n    clazz.prototype = new F();\n    for (var prop in clazzPrototype) {\n        if (clazzPrototype.hasOwnProperty(prop)) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n    }\n    clazz.prototype.constructor = clazz;\n    clazz.superClass = baseClazz;\n}\nexport function mixin(target, source, override) {\n    target = 'prototype' in target ? target.prototype : target;\n    source = 'prototype' in source ? source.prototype : source;\n    if (Object.getOwnPropertyNames) {\n        var keyList = Object.getOwnPropertyNames(source);\n        for (var i = 0; i < keyList.length; i++) {\n            var key = keyList[i];\n            if (key !== 'constructor') {\n                if ((override ? source[key] != null : target[key] == null)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    else {\n        defaults(target, source, override);\n    }\n}\nexport function isArrayLike(data) {\n    if (!data) {\n        return false;\n    }\n    if (typeof data === 'string') {\n        return false;\n    }\n    return typeof data.length === 'number';\n}\nexport function each(arr, cb, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    if (arr.forEach && arr.forEach === nativeForEach) {\n        arr.forEach(cb, context);\n    }\n    else if (arr.length === +arr.length) {\n        for (var i = 0, len = arr.length; i < len; i++) {\n            cb.call(context, arr[i], i, arr);\n        }\n    }\n    else {\n        for (var key in arr) {\n            if (arr.hasOwnProperty(key)) {\n                cb.call(context, arr[key], key, arr);\n            }\n        }\n    }\n}\nexport function map(arr, cb, context) {\n    if (!arr) {\n        return [];\n    }\n    if (!cb) {\n        return slice(arr);\n    }\n    if (arr.map && arr.map === nativeMap) {\n        return arr.map(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            result.push(cb.call(context, arr[i], i, arr));\n        }\n        return result;\n    }\n}\nexport function reduce(arr, cb, memo, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    for (var i = 0, len = arr.length; i < len; i++) {\n        memo = cb.call(context, memo, arr[i], i, arr);\n    }\n    return memo;\n}\nexport function filter(arr, cb, context) {\n    if (!arr) {\n        return [];\n    }\n    if (!cb) {\n        return slice(arr);\n    }\n    if (arr.filter && arr.filter === nativeFilter) {\n        return arr.filter(cb, context);\n    }\n    else {\n        var result = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (cb.call(context, arr[i], i, arr)) {\n                result.push(arr[i]);\n            }\n        }\n        return result;\n    }\n}\nexport function find(arr, cb, context) {\n    if (!(arr && cb)) {\n        return;\n    }\n    for (var i = 0, len = arr.length; i < len; i++) {\n        if (cb.call(context, arr[i], i, arr)) {\n            return arr[i];\n        }\n    }\n}\nexport function keys(obj) {\n    if (!obj) {\n        return [];\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keyList = [];\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            keyList.push(key);\n        }\n    }\n    return keyList;\n}\nfunction bindPolyfill(func, context) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return function () {\n        return func.apply(context, args.concat(nativeSlice.call(arguments)));\n    };\n}\nexport var bind = (protoFunction && isFunction(protoFunction.bind))\n    ? protoFunction.call.bind(protoFunction.bind)\n    : bindPolyfill;\nfunction curry(func) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return function () {\n        return func.apply(this, args.concat(nativeSlice.call(arguments)));\n    };\n}\nexport { curry };\nexport function isArray(value) {\n    if (Array.isArray) {\n        return Array.isArray(value);\n    }\n    return objToString.call(value) === '[object Array]';\n}\nexport function isFunction(value) {\n    return typeof value === 'function';\n}\nexport function isString(value) {\n    return typeof value === 'string';\n}\nexport function isStringSafe(value) {\n    return objToString.call(value) === '[object String]';\n}\nexport function isNumber(value) {\n    return typeof value === 'number';\n}\nexport function isObject(value) {\n    var type = typeof value;\n    return type === 'function' || (!!value && type === 'object');\n}\nexport function isBuiltInObject(value) {\n    return !!BUILTIN_OBJECT[objToString.call(value)];\n}\nexport function isTypedArray(value) {\n    return !!TYPED_ARRAY[objToString.call(value)];\n}\nexport function isDom(value) {\n    return typeof value === 'object'\n        && typeof value.nodeType === 'number'\n        && typeof value.ownerDocument === 'object';\n}\nexport function isGradientObject(value) {\n    return value.colorStops != null;\n}\nexport function isPatternObject(value) {\n    return value.image != null;\n}\nexport function isRegExp(value) {\n    return objToString.call(value) === '[object RegExp]';\n}\nexport function eqNaN(value) {\n    return value !== value;\n}\nexport function retrieve() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    for (var i = 0, len = args.length; i < len; i++) {\n        if (args[i] != null) {\n            return args[i];\n        }\n    }\n}\nexport function retrieve2(value0, value1) {\n    return value0 != null\n        ? value0\n        : value1;\n}\nexport function retrieve3(value0, value1, value2) {\n    return value0 != null\n        ? value0\n        : value1 != null\n            ? value1\n            : value2;\n}\nexport function slice(arr) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return nativeSlice.apply(arr, args);\n}\nexport function normalizeCssArray(val) {\n    if (typeof (val) === 'number') {\n        return [val, val, val, val];\n    }\n    var len = val.length;\n    if (len === 2) {\n        return [val[0], val[1], val[0], val[1]];\n    }\n    else if (len === 3) {\n        return [val[0], val[1], val[2], val[1]];\n    }\n    return val;\n}\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(message);\n    }\n}\nexport function trim(str) {\n    if (str == null) {\n        return null;\n    }\n    else if (typeof str.trim === 'function') {\n        return str.trim();\n    }\n    else {\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n}\nvar primitiveKey = '__ec_primitive__';\nexport function setAsPrimitive(obj) {\n    obj[primitiveKey] = true;\n}\nexport function isPrimitive(obj) {\n    return obj[primitiveKey];\n}\nvar HashMap = (function () {\n    function HashMap(obj) {\n        this.data = {};\n        var isArr = isArray(obj);\n        this.data = {};\n        var thisMap = this;\n        (obj instanceof HashMap)\n            ? obj.each(visit)\n            : (obj && each(obj, visit));\n        function visit(value, key) {\n            isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n        }\n    }\n    HashMap.prototype.get = function (key) {\n        return this.data.hasOwnProperty(key) ? this.data[key] : null;\n    };\n    HashMap.prototype.set = function (key, value) {\n        return (this.data[key] = value);\n    };\n    HashMap.prototype.each = function (cb, context) {\n        for (var key in this.data) {\n            if (this.data.hasOwnProperty(key)) {\n                cb.call(context, this.data[key], key);\n            }\n        }\n    };\n    HashMap.prototype.keys = function () {\n        return keys(this.data);\n    };\n    HashMap.prototype.removeKey = function (key) {\n        delete this.data[key];\n    };\n    return HashMap;\n}());\nexport { HashMap };\nexport function createHashMap(obj) {\n    return new HashMap(obj);\n}\nexport function concatArray(a, b) {\n    var newArray = new a.constructor(a.length + b.length);\n    for (var i = 0; i < a.length; i++) {\n        newArray[i] = a[i];\n    }\n    var offset = a.length;\n    for (var i = 0; i < b.length; i++) {\n        newArray[i + offset] = b[i];\n    }\n    return newArray;\n}\nexport function createObject(proto, properties) {\n    var obj;\n    if (Object.create) {\n        obj = Object.create(proto);\n    }\n    else {\n        var StyleCtor = function () { };\n        StyleCtor.prototype = proto;\n        obj = new StyleCtor();\n    }\n    if (properties) {\n        extend(obj, properties);\n    }\n    return obj;\n}\nexport function hasOwn(own, prop) {\n    return own.hasOwnProperty(prop);\n}\nexport function noop() { }\n","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util';\nvar RADIAN_EPSILON = 1e-4;\n\nfunction _trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function linearMap(val, domain, range, clamp) {\n  var subDomain = domain[1] - domain[0];\n  var subRange = range[1] - range[0];\n\n  if (subDomain === 0) {\n    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n  }\n\n  if (clamp) {\n    if (subDomain > 0) {\n      if (val <= domain[0]) {\n        return range[0];\n      } else if (val >= domain[1]) {\n        return range[1];\n      }\n    } else {\n      if (val >= domain[0]) {\n        return range[0];\n      } else if (val <= domain[1]) {\n        return range[1];\n      }\n    }\n  } else {\n    if (val === domain[0]) {\n      return range[0];\n    }\n\n    if (val === domain[1]) {\n      return range[1];\n    }\n  }\n\n  return (val - domain[0]) / subDomain * subRange + range[0];\n}\nexport function parsePercent(percent, all) {\n  switch (percent) {\n    case 'center':\n    case 'middle':\n      percent = '50%';\n      break;\n\n    case 'left':\n    case 'top':\n      percent = '0%';\n      break;\n\n    case 'right':\n    case 'bottom':\n      percent = '100%';\n      break;\n  }\n\n  if (typeof percent === 'string') {\n    if (_trim(percent).match(/%$/)) {\n      return parseFloat(percent) / 100 * all;\n    }\n\n    return parseFloat(percent);\n  }\n\n  return percent == null ? NaN : +percent;\n}\nexport function round(x, precision, returnStr) {\n  if (precision == null) {\n    precision = 10;\n  }\n\n  precision = Math.min(Math.max(0, precision), 20);\n  x = (+x).toFixed(precision);\n  return returnStr ? x : +x;\n}\nexport function asc(arr) {\n  arr.sort(function (a, b) {\n    return a - b;\n  });\n  return arr;\n}\nexport function getPrecision(val) {\n  val = +val;\n\n  if (isNaN(val)) {\n    return 0;\n  }\n\n  var e = 1;\n  var count = 0;\n\n  while (Math.round(val * e) / e !== val) {\n    e *= 10;\n    count++;\n  }\n\n  return count;\n}\nexport function getPrecisionSafe(val) {\n  var str = val.toString();\n  var eIndex = str.indexOf('e');\n\n  if (eIndex > 0) {\n    var precision = +str.slice(eIndex + 1);\n    return precision < 0 ? -precision : 0;\n  } else {\n    var dotIndex = str.indexOf('.');\n    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n  }\n}\nexport function getPixelPrecision(dataExtent, pixelExtent) {\n  var log = Math.log;\n  var LN10 = Math.LN10;\n  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n  return !isFinite(precision) ? 20 : precision;\n}\nexport function getPercentWithPrecision(valueList, idx, precision) {\n  if (!valueList[idx]) {\n    return 0;\n  }\n\n  var sum = zrUtil.reduce(valueList, function (acc, val) {\n    return acc + (isNaN(val) ? 0 : val);\n  }, 0);\n\n  if (sum === 0) {\n    return 0;\n  }\n\n  var digits = Math.pow(10, precision);\n  var votesPerQuota = zrUtil.map(valueList, function (val) {\n    return (isNaN(val) ? 0 : val) / sum * digits * 100;\n  });\n  var targetSeats = digits * 100;\n  var seats = zrUtil.map(votesPerQuota, function (votes) {\n    return Math.floor(votes);\n  });\n  var currentSum = zrUtil.reduce(seats, function (acc, val) {\n    return acc + val;\n  }, 0);\n  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n    return votes - seats[idx];\n  });\n\n  while (currentSum < targetSeats) {\n    var max = Number.NEGATIVE_INFINITY;\n    var maxId = null;\n\n    for (var i = 0, len = remainder.length; i < len; ++i) {\n      if (remainder[i] > max) {\n        max = remainder[i];\n        maxId = i;\n      }\n    }\n\n    ++seats[maxId];\n    remainder[maxId] = 0;\n    ++currentSum;\n  }\n\n  return seats[idx] / digits;\n}\nexport var MAX_SAFE_INTEGER = 9007199254740991;\nexport function remRadian(radian) {\n  var pi2 = Math.PI * 2;\n  return (radian % pi2 + pi2) % pi2;\n}\nexport function isRadianAroundZero(val) {\n  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n}\nvar TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/;\nexport function parseDate(value) {\n  if (value instanceof Date) {\n    return value;\n  } else if (typeof value === 'string') {\n    var match = TIME_REG.exec(value);\n\n    if (!match) {\n      return new Date(NaN);\n    }\n\n    if (!match[8]) {\n      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n    } else {\n      var hour = +match[4] || 0;\n\n      if (match[8].toUpperCase() !== 'Z') {\n        hour -= +match[8].slice(0, 3);\n      }\n\n      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n    }\n  } else if (value == null) {\n    return new Date(NaN);\n  }\n\n  return new Date(Math.round(value));\n}\nexport function quantity(val) {\n  return Math.pow(10, quantityExponent(val));\n}\nexport function quantityExponent(val) {\n  if (val === 0) {\n    return 0;\n  }\n\n  var exp = Math.floor(Math.log(val) / Math.LN10);\n\n  if (val / Math.pow(10, exp) >= 10) {\n    exp++;\n  }\n\n  return exp;\n}\nexport function nice(val, round) {\n  var exponent = quantityExponent(val);\n  var exp10 = Math.pow(10, exponent);\n  var f = val / exp10;\n  var nf;\n\n  if (round) {\n    if (f < 1.5) {\n      nf = 1;\n    } else if (f < 2.5) {\n      nf = 2;\n    } else if (f < 4) {\n      nf = 3;\n    } else if (f < 7) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  } else {\n    if (f < 1) {\n      nf = 1;\n    } else if (f < 2) {\n      nf = 2;\n    } else if (f < 3) {\n      nf = 3;\n    } else if (f < 5) {\n      nf = 5;\n    } else {\n      nf = 10;\n    }\n  }\n\n  val = nf * exp10;\n  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n}\nexport function quantile(ascArr, p) {\n  var H = (ascArr.length - 1) * p + 1;\n  var h = Math.floor(H);\n  var v = +ascArr[h - 1];\n  var e = H - h;\n  return e ? v + e * (ascArr[h] - v) : v;\n}\nexport function reformIntervals(list) {\n  list.sort(function (a, b) {\n    return littleThan(a, b, 0) ? -1 : 1;\n  });\n  var curr = -Infinity;\n  var currClose = 1;\n\n  for (var i = 0; i < list.length;) {\n    var interval = list[i].interval;\n    var close_1 = list[i].close;\n\n    for (var lg = 0; lg < 2; lg++) {\n      if (interval[lg] <= curr) {\n        interval[lg] = curr;\n        close_1[lg] = !lg ? 1 - currClose : 1;\n      }\n\n      curr = interval[lg];\n      currClose = close_1[lg];\n    }\n\n    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {\n      list.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return list;\n\n  function littleThan(a, b, lg) {\n    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n  }\n}\nexport function numericToNumber(val) {\n  var valFloat = parseFloat(val);\n  return valFloat == val && (valFloat !== 0 || typeof val !== 'string' || val.indexOf('x') <= 0) ? valFloat : NaN;\n}\nexport function isNumeric(val) {\n  return !isNaN(numericToNumber(val));\n}\nexport function getRandomIdBase() {\n  return Math.round(Math.random() * 9);\n}\nexport function getGreatestCommonDividor(a, b) {\n  if (b === 0) {\n    return a;\n  }\n\n  return getGreatestCommonDividor(b, a % b);\n}\nexport function getLeastCommonMultiple(a, b) {\n  if (a == null) {\n    return b;\n  }\n\n  if (b == null) {\n    return a;\n  }\n\n  return a * b / getGreatestCommonDividor(a, b);\n}","import * as echarts from 'echarts/lib/echarts';\n\nexport default echarts.graphic.extendShape({\n    type: 'ec-liquid-fill',\n\n    shape: {\n        waveLength: 0,\n        radius: 0,\n        radiusY: 0,\n        cx: 0,\n        cy: 0,\n        waterLevel: 0,\n        amplitude: 0,\n        phase: 0,\n        inverse: false\n    },\n\n    buildPath: function (ctx, shape) {\n        if (shape.radiusY == null) {\n            shape.radiusY = shape.radius;\n        }\n\n        /**\n         * We define a sine wave having 4 waves, and make sure at least 8 curves\n         * is drawn. Otherwise, it may cause blank area for some waves when\n         * wave length is large enough.\n         */\n        var curves = Math.max(\n            Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2,\n            8\n        );\n\n        // map phase to [-Math.PI * 2, 0]\n        while (shape.phase < -Math.PI * 2) {\n            shape.phase += Math.PI * 2;\n        }\n        while (shape.phase > 0) {\n            shape.phase -= Math.PI * 2;\n        }\n        var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n\n        var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n        /**\n         * top-left corner as start point\n         *\n         * draws this point\n         *  |\n         * \\|/\n         *  ~~~~~~~~\n         *  |      |\n         *  +------+\n         */\n        ctx.moveTo(left, shape.waterLevel);\n\n        /**\n         * top wave\n         *\n         * ~~~~~~~~ <- draws this sine wave\n         * |      |\n         * +------+\n         */\n        var waveRight = 0;\n        for (var c = 0; c < curves; ++c) {\n            var stage = c % 4;\n            var pos = getWaterPositions(c * shape.waveLength / 4, stage,\n                shape.waveLength, shape.amplitude);\n            ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel,\n                pos[1][0] + left, -pos[1][1] + shape.waterLevel,\n                pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n            if (c === curves - 1) {\n                waveRight = pos[2][0];\n            }\n        }\n\n        if (shape.inverse) {\n            /**\n             * top-right corner\n             *                  2. draws this line\n             *                          |\n             *                       +------+\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       ~~~~~~~~\n             */\n            ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n        else {\n            /**\n             * top-right corner\n             *\n             *                       ~~~~~~~~\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       +------+\n             *                          ^\n             *                          |\n             *                  2. draws this line\n             */\n            ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n\n        ctx.closePath();\n    }\n});\n\n\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n    if (stage === 0) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     amplitude],\n            [x + waveLength / 4,                   amplitude]\n        ];\n    }\n    else if (stage === 1) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n    else if (stage === 2) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     -amplitude],\n            [x + waveLength / 4,                   -amplitude]\n        ]\n    }\n    else {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            -amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            -amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n}\n","import * as echarts from 'echarts/lib/echarts';\nimport * as numberUtil from 'echarts/lib/util/number';\nimport LiquidShape from './liquidFillShape';\n\nconst parsePercent = numberUtil.parsePercent;\n\necharts.extendChartView({\n\n    type: 'liquidFill',\n\n    render: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n\n        var data = seriesModel.getData();\n\n        var itemModel = data.getItemModel(0);\n\n        var center = itemModel.get('center');\n        var radius = itemModel.get('radius');\n\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        // itemStyle\n        var outlineDistance = 0;\n        var outlineBorderWidth = 0;\n        var showOutline = seriesModel.get('outline.show');\n\n        if (showOutline) {\n            outlineDistance = seriesModel.get('outline.borderDistance');\n            outlineBorderWidth = parsePercent(\n                seriesModel.get('outline.itemStyle.borderWidth'), size\n            );\n        }\n\n        var cx = parsePercent(center[0], width);\n        var cy = parsePercent(center[1], height);\n\n        var outterRadius;\n        var innerRadius;\n        var paddingRadius;\n\n        var isFillContainer = false;\n\n        var symbol = seriesModel.get('shape');\n        if (symbol === 'container') {\n            // a shape that fully fills the container\n            isFillContainer = true;\n\n            outterRadius = [\n                width / 2,\n                height / 2\n            ];\n            innerRadius = [\n                outterRadius[0] - outlineBorderWidth / 2,\n                outterRadius[1] - outlineBorderWidth / 2\n            ];\n            paddingRadius = [\n                parsePercent(outlineDistance, width),\n                parsePercent(outlineDistance, height)\n            ];\n\n            radius = [\n                Math.max(innerRadius[0] - paddingRadius[0], 0),\n                Math.max(innerRadius[1] - paddingRadius[1], 0)\n            ];\n        }\n        else {\n            outterRadius = parsePercent(radius, size) / 2;\n            innerRadius = outterRadius - outlineBorderWidth / 2;\n            paddingRadius = parsePercent(outlineDistance, size);\n\n            radius = Math.max(innerRadius - paddingRadius, 0);\n        }\n\n        if (showOutline) {\n            var outline = getOutline();\n            outline.style.lineWidth = outlineBorderWidth;\n            group.add(getOutline());\n        }\n\n        var left = isFillContainer ? 0 : cx - radius;\n        var top = isFillContainer ? 0 : cy - radius;\n\n        var wavePath = null;\n\n        group.add(getBackground());\n\n        // each data item for a wave\n        var oldData = this._data;\n        var waves = [];\n        data.diff(oldData)\n            .add(function (idx) {\n                var wave = getWave(idx, false);\n\n                var waterLevel = wave.shape.waterLevel;\n                wave.shape.waterLevel = isFillContainer ? height / 2 : radius;\n                echarts.graphic.initProps(wave, {\n                    shape: {\n                        waterLevel: waterLevel\n                    }\n                }, seriesModel);\n\n                wave.z2 = 2;\n                setWaveAnimation(idx, wave, null);\n\n                group.add(wave);\n                data.setItemGraphicEl(idx, wave);\n                waves.push(wave);\n            })\n            .update(function (newIdx, oldIdx) {\n                var waveElement = oldData.getItemGraphicEl(oldIdx);\n\n                // new wave is used to calculate position, but not added\n                var newWave = getWave(newIdx, false, waveElement);\n\n                // changes with animation\n                var shape = {};\n                var shapeAttrs = ['amplitude', 'cx', 'cy', 'phase', 'radius', 'radiusY', 'waterLevel', 'waveLength'];\n                for (var i = 0; i < shapeAttrs.length; ++i) {\n                    var attr = shapeAttrs[i];\n                    if (newWave.shape.hasOwnProperty(attr)) {\n                        shape[attr] = newWave.shape[attr];\n                    }\n                }\n\n                var style = {};\n                var styleAttrs = ['fill', 'opacity', 'shadowBlur', 'shadowColor'];\n                for (var i = 0; i < styleAttrs.length; ++i) {\n                    var attr = styleAttrs[i];\n                    if (newWave.style.hasOwnProperty(attr)) {\n                        style[attr] = newWave.style[attr];\n                    }\n                }\n\n                if (isFillContainer) {\n                    shape.radiusY = height / 2;\n                }\n\n                // changes with animation\n                echarts.graphic.updateProps(waveElement, {\n                    shape: shape\n                }, seriesModel);\n\n                waveElement.useStyle(style);\n\n                // instant changes\n                waveElement.position = newWave.position;\n                waveElement.setClipPath(newWave.getClipPath());\n                waveElement.shape.inverse = newWave.inverse;\n\n                setWaveAnimation(newIdx, waveElement, waveElement);\n                group.add(waveElement);\n                data.setItemGraphicEl(newIdx, waveElement);\n                waves.push(waveElement);\n            })\n            .remove(function (idx) {\n                var wave = oldData.getItemGraphicEl(idx);\n                group.remove(wave);\n            })\n            .execute();\n\n        if (itemModel.get('label.show')) {\n            group.add(getText(waves));\n        }\n\n        this._data = data;\n\n        /**\n         * Get path for outline, background and clipping\n         *\n         * @param {number} r outter radius of shape\n         * @param {boolean|undefined} isForClipping if the shape is used\n         *                                          for clipping\n         */\n        function getPath(r, isForClipping) {\n            if (symbol) {\n                // customed symbol path\n                if (symbol.indexOf('path://') === 0) {\n                    var path = echarts.graphic.makePath(symbol.slice(7), {});\n                    var bouding = path.getBoundingRect();\n                    var w = bouding.width;\n                    var h = bouding.height;\n                    if (w > h) {\n                        h = r * 2 / w * h;\n                        w = r * 2;\n                    }\n                    else {\n                        w = r * 2 / h * w;\n                        h = r * 2;\n                    }\n\n                    var left = isForClipping ? 0 : cx - w / 2;\n                    var top = isForClipping ? 0 : cy - h / 2;\n                    path = echarts.graphic.makePath(\n                        symbol.slice(7),\n                        {},\n                        new echarts.graphic.BoundingRect(left, top, w, h)\n                    );\n                    if (isForClipping) {\n                        path.position = [-w / 2, -h / 2];\n                    }\n                    return path;\n                }\n                else if (isFillContainer) {\n                    // fully fill the container\n                    var x = isForClipping ? -r[0] : cx - r[0];\n                    var y = isForClipping ? -r[1] : cy - r[1];\n                    return echarts.helper.createSymbol(\n                        'rect', x, y, r[0] * 2, r[1] * 2\n                    );\n                }\n                else {\n                    var x = isForClipping ? -r : cx - r;\n                    var y = isForClipping ? -r : cy - r;\n                    if (symbol === 'pin') {\n                        y += r;\n                    }\n                    else if (symbol === 'arrow') {\n                        y -= r;\n                    }\n                    return echarts.helper.createSymbol(symbol, x, y, r * 2, r * 2);\n                }\n            }\n\n            return new echarts.graphic.Circle({\n                shape: {\n                    cx: isForClipping ? 0 : cx,\n                    cy: isForClipping ? 0 : cy,\n                    r: r\n                }\n            });\n        }\n        /**\n         * Create outline\n         */\n        function getOutline() {\n            var outlinePath = getPath(outterRadius);\n            outlinePath.style.fill = null;\n\n            outlinePath.setStyle(seriesModel.getModel('outline.itemStyle')\n                .getItemStyle());\n\n            return outlinePath;\n        }\n\n        /**\n         * Create background\n         */\n        function getBackground() {\n            // Seperate stroke and fill, so we can use stroke to cover the alias of clipping.\n            var strokePath = getPath(radius);\n            strokePath.setStyle(seriesModel.getModel('backgroundStyle')\n                .getItemStyle());\n            strokePath.style.fill = null;\n\n            // Stroke is front of wave\n            strokePath.z2 = 5;\n\n            var fillPath = getPath(radius);\n            fillPath.setStyle(seriesModel.getModel('backgroundStyle')\n                .getItemStyle());\n            fillPath.style.stroke = null;\n\n            var group = new echarts.graphic.Group();\n            group.add(strokePath);\n            group.add(fillPath);\n\n            return group;\n        }\n\n        /**\n         * wave shape\n         */\n        function getWave(idx, isInverse, oldWave) {\n            var radiusX = isFillContainer ? radius[0] : radius;\n            var radiusY = isFillContainer ? height / 2 : radius;\n\n            var itemModel = data.getItemModel(idx);\n            var itemStyleModel = itemModel.getModel('itemStyle');\n            var phase = itemModel.get('phase');\n            var amplitude = parsePercent(itemModel.get('amplitude'),\n                radiusY * 2);\n            var waveLength = parsePercent(itemModel.get('waveLength'),\n                radiusX * 2);\n\n            var value = data.get('value', idx);\n            var waterLevel = radiusY - value * radiusY * 2;\n            phase = oldWave ? oldWave.shape.phase\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\n            var normalStyle = itemStyleModel.getItemStyle();\n            if (!normalStyle.fill) {\n                var seriesColor = seriesModel.get('color');\n                var id = idx % seriesColor.length;\n                normalStyle.fill = seriesColor[id];\n            }\n\n            var x = radiusX * 2;\n            var wave = new LiquidShape({\n                shape: {\n                    waveLength: waveLength,\n                    radius: radiusX,\n                    radiusY: radiusY,\n                    cx: x,\n                    cy: 0,\n                    waterLevel: waterLevel,\n                    amplitude: amplitude,\n                    phase: phase,\n                    inverse: isInverse\n                },\n                style: normalStyle,\n                position: [cx, cy]\n            });\n            wave.shape._waterLevel = waterLevel;\n\n            var hoverStyle = itemModel.getModel('emphasis.itemStyle')\n                .getItemStyle();\n            hoverStyle.lineWidth = 0;\n\n            wave.ensureState('emphasis').style = hoverStyle;\n            echarts.helper.enableHoverEmphasis(wave);\n\n            // clip out the part outside the circle\n            var clip = getPath(radius, true);\n            // set fill for clipPath, otherwise it will not trigger hover event\n            clip.setStyle({\n                fill: 'white'\n            });\n            wave.setClipPath(clip);\n\n            return wave;\n        }\n\n        function setWaveAnimation(idx, wave, oldWave) {\n            var itemModel = data.getItemModel(idx);\n\n            var maxSpeed = itemModel.get('period');\n            var direction = itemModel.get('direction');\n\n            var value = data.get('value', idx);\n\n            var phase = itemModel.get('phase');\n            phase = oldWave ? oldWave.shape.phase\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\n\n            var defaultSpeed = function (maxSpeed) {\n                var cnt = data.count();\n                return cnt === 0 ? maxSpeed : maxSpeed *\n                    (0.2 + (cnt - idx) / cnt * 0.8);\n            };\n            var speed = 0;\n            if (maxSpeed === 'auto') {\n                speed = defaultSpeed(5000);\n            }\n            else {\n                speed = typeof maxSpeed === 'function'\n                    ? maxSpeed(value, idx) : maxSpeed;\n            }\n\n            // phase for moving left/right\n            var phaseOffset = 0;\n            if (direction === 'right' || direction == null) {\n                phaseOffset = Math.PI;\n            }\n            else if (direction === 'left') {\n                phaseOffset = -Math.PI;\n            }\n            else if (direction === 'none') {\n                phaseOffset = 0;\n            }\n            else {\n                console.error('Illegal direction value for liquid fill.');\n            }\n\n            // wave animation of moving left/right\n            if (direction !== 'none' && itemModel.get('waveAnimation')) {\n                wave\n                    .animate('shape', true)\n                    .when(0, {\n                        phase: phase\n                    })\n                    .when(speed / 2, {\n                        phase: phaseOffset + phase\n                    })\n                    .when(speed, {\n                        phase: phaseOffset * 2 + phase\n                    })\n                    .during(function () {\n                        if (wavePath) {\n                            wavePath.dirty(true);\n                        }\n                    })\n                    .start();\n            }\n        }\n\n        /**\n         * text on wave\n         */\n        function getText(waves) {\n            var labelModel = itemModel.getModel('label');\n\n            function formatLabel() {\n                var formatted = seriesModel.getFormattedLabel(0, 'normal');\n                var defaultVal = (data.get('value', 0) * 100);\n                var defaultLabel = data.getName(0) || seriesModel.name;\n                if (!isNaN(defaultVal)) {\n                    defaultLabel = defaultVal.toFixed(0) + '%';\n                }\n                return formatted == null ? defaultLabel : formatted;\n            }\n\n            var textRectOption = {\n                z2: 10,\n                shape: {\n                    x: left,\n                    y: top,\n                    width: (isFillContainer ? radius[0] : radius) * 2,\n                    height: (isFillContainer ? radius[1] : radius) * 2\n                },\n                style: {\n                    fill: 'transparent'\n                },\n                textConfig: {\n                    position: labelModel.get('position') || 'inside'\n                },\n                silent: true\n            };\n            var textOption = {\n                style: {\n                    text: formatLabel(),\n                    textAlign: labelModel.get('align'),\n                    textVerticalAlign: labelModel.get('baseline')\n                }\n            };\n            Object.assign(textOption.style, echarts.helper.createTextStyle(labelModel));\n\n            var outsideTextRect = new echarts.graphic.Rect(textRectOption);\n            var insideTextRect = new echarts.graphic.Rect(textRectOption);\n            insideTextRect.disableLabelAnimation = true;\n            outsideTextRect.disableLabelAnimation = true;\n\n            var outsideText = new echarts.graphic.Text(textOption);\n            var insideText = new echarts.graphic.Text(textOption);\n            outsideTextRect.setTextContent(outsideText);\n\n            insideTextRect.setTextContent(insideText);\n            var insColor = labelModel.get('insideColor');\n            insideText.style.fill = insColor;\n\n            var group = new echarts.graphic.Group();\n            group.add(outsideTextRect);\n            group.add(insideTextRect);\n\n            // clip out waves for insideText\n            var boundingCircle = getPath(radius, true);\n\n            wavePath = new echarts.graphic.CompoundPath({\n                shape: {\n                    paths: waves\n                },\n                position: [cx, cy]\n            });\n\n            wavePath.setClipPath(boundingCircle);\n            insideTextRect.setClipPath(wavePath);\n\n            return group;\n        }\n    },\n\n    dispose: function () {\n        // dispose nothing here\n    }\n});\n","module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./index.js\");\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}