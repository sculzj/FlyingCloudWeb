{"ast":null,"code":"import * as echarts from 'echarts/lib/echarts';\nexport default echarts.graphic.extendShape({\n  type: 'ec-liquid-fill',\n  shape: {\n    waveLength: 0,\n    radius: 0,\n    radiusY: 0,\n    cx: 0,\n    cy: 0,\n    waterLevel: 0,\n    amplitude: 0,\n    phase: 0,\n    inverse: false\n  },\n  buildPath: function (ctx, shape) {\n    if (shape.radiusY == null) {\n      shape.radiusY = shape.radius;\n    }\n    /**\n     * We define a sine wave having 4 waves, and make sure at least 8 curves\n     * is drawn. Otherwise, it may cause blank area for some waves when\n     * wave length is large enough.\n     */\n\n\n    var curves = Math.max(Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2, 8); // map phase to [-Math.PI * 2, 0]\n\n    while (shape.phase < -Math.PI * 2) {\n      shape.phase += Math.PI * 2;\n    }\n\n    while (shape.phase > 0) {\n      shape.phase -= Math.PI * 2;\n    }\n\n    var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n    var left = shape.cx - shape.radius + phase - shape.radius * 2;\n    /**\n     * top-left corner as start point\n     *\n     * draws this point\n     *  |\n     * \\|/\n     *  ~~~~~~~~\n     *  |      |\n     *  +------+\n     */\n\n    ctx.moveTo(left, shape.waterLevel);\n    /**\n     * top wave\n     *\n     * ~~~~~~~~ <- draws this sine wave\n     * |      |\n     * +------+\n     */\n\n    var waveRight = 0;\n\n    for (var c = 0; c < curves; ++c) {\n      var stage = c % 4;\n      var pos = getWaterPositions(c * shape.waveLength / 4, stage, shape.waveLength, shape.amplitude);\n      ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel, pos[1][0] + left, -pos[1][1] + shape.waterLevel, pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n      if (c === curves - 1) {\n        waveRight = pos[2][0];\n      }\n    }\n\n    if (shape.inverse) {\n      /**\n       * top-right corner\n       *                  2. draws this line\n       *                          |\n       *                       +------+\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       ~~~~~~~~\n       */\n      ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.cy - shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    } else {\n      /**\n       * top-right corner\n       *\n       *                       ~~~~~~~~\n       * 3. draws this line -> |      | <- 1. draws this line\n       *                       +------+\n       *                          ^\n       *                          |\n       *                  2. draws this line\n       */\n      ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.cy + shape.radiusY);\n      ctx.lineTo(left, shape.waterLevel);\n    }\n\n    ctx.closePath();\n  }\n});\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\n\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n  if (stage === 0) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];\n  } else if (stage === 1) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];\n  } else if (stage === 2) {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];\n  } else {\n    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];\n  }\n}","map":{"version":3,"sources":["D:/WebStorm Project/flowingcloud/node_modules/echarts-liquidfill/src/liquidFillShape.js"],"names":["echarts","graphic","extendShape","type","shape","waveLength","radius","radiusY","cx","cy","waterLevel","amplitude","phase","inverse","buildPath","ctx","curves","Math","max","ceil","PI","left","moveTo","waveRight","c","stage","pos","getWaterPositions","bezierCurveTo","lineTo","closePath","x"],"mappings":"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","sourcesContent":["import * as echarts from 'echarts/lib/echarts';\n\nexport default echarts.graphic.extendShape({\n    type: 'ec-liquid-fill',\n\n    shape: {\n        waveLength: 0,\n        radius: 0,\n        radiusY: 0,\n        cx: 0,\n        cy: 0,\n        waterLevel: 0,\n        amplitude: 0,\n        phase: 0,\n        inverse: false\n    },\n\n    buildPath: function (ctx, shape) {\n        if (shape.radiusY == null) {\n            shape.radiusY = shape.radius;\n        }\n\n        /**\n         * We define a sine wave having 4 waves, and make sure at least 8 curves\n         * is drawn. Otherwise, it may cause blank area for some waves when\n         * wave length is large enough.\n         */\n        var curves = Math.max(\n            Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2,\n            8\n        );\n\n        // map phase to [-Math.PI * 2, 0]\n        while (shape.phase < -Math.PI * 2) {\n            shape.phase += Math.PI * 2;\n        }\n        while (shape.phase > 0) {\n            shape.phase -= Math.PI * 2;\n        }\n        var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n\n        var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n        /**\n         * top-left corner as start point\n         *\n         * draws this point\n         *  |\n         * \\|/\n         *  ~~~~~~~~\n         *  |      |\n         *  +------+\n         */\n        ctx.moveTo(left, shape.waterLevel);\n\n        /**\n         * top wave\n         *\n         * ~~~~~~~~ <- draws this sine wave\n         * |      |\n         * +------+\n         */\n        var waveRight = 0;\n        for (var c = 0; c < curves; ++c) {\n            var stage = c % 4;\n            var pos = getWaterPositions(c * shape.waveLength / 4, stage,\n                shape.waveLength, shape.amplitude);\n            ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel,\n                pos[1][0] + left, -pos[1][1] + shape.waterLevel,\n                pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n            if (c === curves - 1) {\n                waveRight = pos[2][0];\n            }\n        }\n\n        if (shape.inverse) {\n            /**\n             * top-right corner\n             *                  2. draws this line\n             *                          |\n             *                       +------+\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       ~~~~~~~~\n             */\n            ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n        else {\n            /**\n             * top-right corner\n             *\n             *                       ~~~~~~~~\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       +------+\n             *                          ^\n             *                          |\n             *                  2. draws this line\n             */\n            ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n\n        ctx.closePath();\n    }\n});\n\n\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n    if (stage === 0) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     amplitude],\n            [x + waveLength / 4,                   amplitude]\n        ];\n    }\n    else if (stage === 1) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n    else if (stage === 2) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     -amplitude],\n            [x + waveLength / 4,                   -amplitude]\n        ]\n    }\n    else {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            -amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            -amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n}\n"]},"metadata":{},"sourceType":"module"}